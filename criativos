<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Criador de Criativos — MVP</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:18px;color:#111}
    h1{font-size:20px;margin:0 0 6px}
    .row{display:flex;gap:12px;align-items:flex-start}
    .panel{background:#fafafa;border:1px solid #eee;padding:12px;border-radius:8px}
    .controls{width:360px}
    label{display:block;margin-top:8px;font-size:13px}
    input[type=text],select,input[type=number]{width:100%;padding:8px;border-radius:6px;border:1px solid #ddd}
    input[type=file]{width:100%}
    button{margin-top:10px;padding:10px 12px;border-radius:8px;border:0;background:#0b74de;color:white;cursor:pointer}
    canvas{background:white;border:1px solid #ddd;border-radius:8px}
    .thumbs{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .thumbs img{width:60px;height:60px;object-fit:cover;border-radius:6px;border:1px solid #ccc}
    small{color:#666}
  </style>
</head>
<body>
  <h1>Criador de Criativos — MVP (100% grátis, roda no browser)</h1>
  <p>Este ficheiro é um MVP que cria imagens para redes sociais a partir das tuas fotos, texto e templates. Também gera um vídeo curto (slideshow) com as imagens. Para ver/editares o código, abre o ficheiro num editor. Para publicar grátis, usa GitHub Pages.</p>

  <div class="row">
    <div class="controls panel">
      <label>Aspecto / Rede social</label>
      <select id="ratio">
        <option value="1080x1080">Instagram (Quadrado) — 1080×1080</option>
        <option value="1080x1920">Story/Reel — 1080×1920</option>
        <option value="1920x1080">YouTube/FB — 1920×1080</option>
      </select>

      <label>Template</label>
      <select id="template">
        <option value="simple">Fundo + produto central</option>
        <option value="grid">Grid de imagens + título</option>
      </select>

      <label>Carregar imagens (arrasta/seleciona até 8)</label>
      <input id="files" type="file" accept="image/*,video/*" multiple />
      <div class="thumbs" id="thumbs"></div>

      <label>Título / Headline</label>
      <input id="headline" type="text" placeholder="Ex: Novo! Oferta 20%" />

      <label>Chamada / Botão (opcional)</label>
      <input id="cta" type="text" placeholder="Ex: Comprar agora" />

      <label>Fonte — tamanho</label>
      <input id="fontsize" type="number" value="56" min="10" max="220" />

      <label>Cor do texto</label>
      <input id="fontcolor" type="color" value="#ffffff" />

      <label><small>Opções</small></label>
      <div style="display:flex;gap:8px">
        <button id="btnRender">Renderizar Preview</button>
        <button id="btnExport">Exportar Imagem</button>
        <button id="btnVideo">Exportar Vídeo (slideshow)</button>
      </div>

      <p style="margin-top:10px"><small>Dica: para melhores resultados use fotos de alta resolução. O vídeo gerado é em WebM (compatibilidade depende do browser).</small></p>
    </div>

    <div class="panel" style="flex:1">
      <canvas id="preview" width="1080" height="1080"></canvas>
    </div>
  </div>

  <script>
    // MVP: carrega imagens do utilizador, desenha templates simples, exporta PNG e grava um slideshow com MediaRecorder.
    const filesEl = document.getElementById('files');
    const thumbs = document.getElementById('thumbs');
    const ratio = document.getElementById('ratio');
    const template = document.getElementById('template');
    const preview = document.getElementById('preview');
    const ctx = preview.getContext('2d');
    const headlineEl = document.getElementById('headline');
    const ctaEl = document.getElementById('cta');
    const fontsizeEl = document.getElementById('fontsize');
    const fontcolorEl = document.getElementById('fontcolor');

    let images = []; // {file, img}

    filesEl.addEventListener('change', async (e)=>{
      const files = Array.from(e.target.files).slice(0,8);
      images = [];
      thumbs.innerHTML='';
      for(const f of files){
        if(!f.type.startsWith('image/')) continue; // para este MVP apenas imagens são usadas
        const data = await readFileAsDataURL(f);
        const img = await createImage(data);
        images.push({file:f,img});
        const el = document.createElement('img'); el.src = data; thumbs.appendChild(el);
      }
      draw();
    });

    ratio.addEventListener('change', ()=>{
      const [w,h] = ratio.value.split('x').map(Number);
      preview.width = w; preview.height = h;
      draw();
    });
    template.addEventListener('change', draw);
    document.getElementById('btnRender').addEventListener('click', draw);
    document.getElementById('btnExport').addEventListener('click', exportImage);
    document.getElementById('btnVideo').addEventListener('click', exportVideo);

    function readFileAsDataURL(file){
      return new Promise((res,rej)=>{
        const r = new FileReader(); r.onload = ()=>res(r.result); r.onerror=rej; r.readAsDataURL(file);
      });
    }
    function createImage(src){
      return new Promise((res,rej)=>{
        const i = new Image(); i.onload = ()=>res(i); i.onerror=rej; i.src = src;
      });
    }

    function draw(){
      // limpar
      ctx.clearRect(0,0,preview.width,preview.height);
      // Background
      ctx.fillStyle = '#222'; ctx.fillRect(0,0,preview.width,preview.height);

      if(images.length>0){
        if(template.value==='simple'){
          // fundo com a primeira imagem esticada/crop
          const bg = images[0].img;
          drawCoverImage(bg,0,0,preview.width,preview.height);
          // se houver mais imagens desenha a segunda como produto central
          if(images[1]){
            const p = images[1].img;
            const pw = preview.width*0.6; const ph = preview.height*0.6;
            ctx.save();
            ctx.beginPath();
            const x = (preview.width-pw)/2; const y = (preview.height-ph)/2;
            roundRect(ctx,x,y,pw,ph,12); ctx.clip();
            drawContainImage(p,x,y,pw,ph);
            ctx.restore();
            // sombra
            ctx.shadowColor='rgba(0,0,0,0.4)';ctx.shadowBlur=30;
          }
        } else {
          // grid template
          const cols = Math.min(3, images.length);
          const rows = Math.ceil(images.length/cols);
          const gap = 8; const cellW = (preview.width - gap*(cols+1))/cols; const cellH = (preview.height - gap*(rows+1))/rows;
          let idx=0;
          for(let r=0;r<rows;r++){
            for(let c=0;c<cols;c++){
              if(!images[idx]) break;
              const x = gap + c*(cellW+gap), y = gap + r*(cellH+gap);
              const img = images[idx].img; drawCoverImage(img,x,y,cellW,cellH);
              idx++;
            }
          }
        }
      }

      // overlay gradient near bottom for text readability
      const g = ctx.createLinearGradient(0, preview.height*0.6, 0, preview.height);
      g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,0.55)');
      ctx.fillStyle = g; ctx.fillRect(0, preview.height*0.5, preview.width, preview.height*0.5);

      // text
      const headline = headlineEl.value.trim();
      const fontsize = Number(fontsizeEl.value) || 48;
      ctx.fillStyle = fontcolorEl.value;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.font = `bold ${fontsize}px Arial`;
      if(headline){
        wrapText(ctx, headline, preview.width/2, preview.height*0.78, preview.width*0.9, fontsize+8);
      }

      const cta = ctaEl.value.trim();
      if(cta){
        ctx.font = `600 ${Math.max(18,Math.floor(fontsize*0.4))}px Arial`;
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.fillText(cta, preview.width/2, preview.height*0.9);
      }
    }

    // util: draw image cover
    function drawCoverImage(img,x,y,w,h){
      const sw = img.width, sh = img.height;
      // cover: scale to fill
      const scale = Math.max(w/sw, h/sh);
      const nw = sw*scale, nh = sh*scale;
      const sx = (nw - w)/2/scale, sy = (nh - h)/2/scale;
      ctx.drawImage(img, sx, sy, sw - sx*2, sh - sy*2, x, y, w, h);
    }
    function drawContainImage(img,x,y,w,h){
      const sw = img.width, sh = img.height;
      const scale = Math.min(w/sw, h/sh);
      const nw = sw*scale, nh = sh*scale;
      const px = x + (w-nw)/2, py = y + (h-nh)/2;
      ctx.drawImage(img, 0,0,sw,sh, px, py, nw, nh);
    }

    function roundRect(ctx,x,y,w,h,r){
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      let testY = y - lineHeight; // start above then adjust
      let lines = [];
      for(let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = context.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
          lines.push(line.trim());
          line = words[n] + ' ';
        }
        else {
          line = testLine;
        }
      }
      lines.push(line.trim());
      // draw lines centered
      const totalH = lines.length * lineHeight;
      let startY = y - totalH/2 + lineHeight/2;
      for(let i=0;i<lines.length;i++){
        context.fillText(lines[i], x, startY + i*lineHeight);
      }
    }

    function exportImage(){
      preview.toBlob((blob)=>{
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `criativo_${Date.now()}.jpg`;
        a.click();
        URL.revokeObjectURL(a.href);
      }, 'image/jpeg', 0.92);
    }

    async function exportVideo(){
      if(images.length<2){ alert('Carrega pelo menos 2 imagens para gerar um slideshow.'); return; }
      // captura stream do canvas
      const stream = preview.captureStream(30); // 30fps
      // escolher mime compatível
      let mime = 'video/webm;codecs=vp9';
      if(!MediaRecorder.isTypeSupported(mime)){
        mime = 'video/webm;codecs=vp8';
        if(!MediaRecorder.isTypeSupported(mime)) mime = '';
      }
      if(mime===''){
        alert('O teu browser não suporta gravação de vídeo a partir do canvas (MediaRecorder). Tenta Chrome, Edge ou Firefox.');
        return;
      }
      const rec = new MediaRecorder(stream, {mimeType:mime});
      const chunks = [];
      rec.ondataavailable = e=>chunks.push(e.data);
      rec.start();

      // animação: mostrar cada imagem por N ms
      const showMs = 1600; // ms por slide
      for(let i=0;i<images.length;i++){
        draw();
        // temporariamente mover current image to first for template draw
        if(template.value==='simple' && i>0){
          // swap index 1 with i for preview effect
          const tmp = images[1]; images[1]=images[i]; draw(); images[1]=tmp;
        } else if(template.value==='grid'){
          // rotate drawing: bring image i to grid position 0
          const tmp = images[0]; images[0]=images[i]; draw(); images[0]=tmp;
        }
        await wait(showMs);
      }

      rec.stop();
      // esperar fim
      await new Promise(res=> rec.onstop = res);
      const blob = new Blob(chunks, {type:mime});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `criativo_slideshow_${Date.now()}.webm`;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function wait(ms){ return new Promise(res=>setTimeout(res,ms)); }

    // inicializar
    (function(){ draw(); })();

  </script>
</body>
</html>

